{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nimport color from 'color';\nimport { ADORNMENT_SIZE, MD3_LABEL_PADDING_HORIZONTAL, MD2_LABEL_PADDING_HORIZONTAL, MD3_ADORNMENT_OFFSET, MD2_ADORNMENT_OFFSET, MD3_FLAT_INPUT_OFFSET, MD2_FLAT_INPUT_OFFSET, MD3_AFFIX_OFFSET, MD2_AFFIX_OFFSET, MD3_ICON_OFFSET, MD2_ICON_OFFSET, MD3_LABEL_PADDING_TOP, MD2_LABEL_PADDING_TOP, MD3_MIN_HEIGHT, MD2_MIN_HEIGHT, MD3_INPUT_PADDING_HORIZONTAL, MD2_INPUT_PADDING_HORIZONTAL, MD3_OUTLINED_INPUT_OFFSET, MD2_OUTLINED_INPUT_OFFSET } from \"./constants\";\nimport { AdornmentType, AdornmentSide } from \"./Adornment/enums\";\nimport { MD3LightTheme } from \"../../styles/themes\";\nexport var calculateLabelTopPosition = function calculateLabelTopPosition(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport var calculateInputHeight = function calculateInputHeight(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var minHeight = arguments.length > 2 ? arguments[2] : undefined;\n  var finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport var calculatePadding = function calculatePadding(props) {\n  var height = props.height,\n    _props$multiline = props.multiline,\n    multiline = _props$multiline === void 0 ? false : _props$multiline;\n  var result = 0;\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n  return Math.max(0, result);\n};\nvar calculateTextAreaPadding = function calculateTextAreaPadding(props) {\n  var dense = props.dense;\n  return dense ? 10 : 20;\n};\nvar calculateInputPadding = function calculateInputPadding(_ref) {\n  var topPosition = _ref.topPosition,\n    fontSize = _ref.fontSize,\n    multiline = _ref.multiline,\n    scale = _ref.scale,\n    dense = _ref.dense,\n    offset = _ref.offset,\n    isAndroid = _ref.isAndroid;\n  var refFontSize = scale * fontSize;\n  var result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\nexport var adjustPaddingOut = function adjustPaddingOut(_ref2) {\n  var pad = _ref2.pad,\n    multiline = _ref2.multiline,\n    label = _ref2.label,\n    scale = _ref2.scale,\n    height = _ref2.height,\n    fontSize = _ref2.fontSize,\n    lineHeight = _ref2.lineHeight,\n    dense = _ref2.dense,\n    offset = _ref2.offset,\n    isAndroid = _ref2.isAndroid;\n  var fontHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : fontSize;\n  var refFontHeight = scale * fontSize;\n  var result = pad;\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2)\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport var adjustPaddingFlat = function adjustPaddingFlat(_ref3) {\n  var pad = _ref3.pad,\n    scale = _ref3.scale,\n    multiline = _ref3.multiline,\n    label = _ref3.label,\n    height = _ref3.height,\n    offset = _ref3.offset,\n    dense = _ref3.dense,\n    fontSize = _ref3.fontSize,\n    isAndroid = _ref3.isAndroid,\n    styles = _ref3.styles;\n  var result = pad;\n  var topResult = result;\n  var bottomResult = result;\n  var paddingTop = styles.paddingTop,\n    paddingBottom = styles.paddingBottom;\n  var refFontSize = scale * fontSize;\n  if (!multiline) {\n    if (label) {\n      return {\n        paddingTop: paddingTop,\n        paddingBottom: paddingBottom\n      };\n    }\n\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n  if (label) {\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    }\n\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport var interpolatePlaceholder = function interpolatePlaceholder(labeled, hasActiveOutline) {\n  return labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1]\n  });\n};\nexport function calculateFlatAffixTopPosition(_ref4) {\n  var height = _ref4.height,\n    paddingTop = _ref4.paddingTop,\n    paddingBottom = _ref4.paddingBottom,\n    affixHeight = _ref4.affixHeight;\n  var inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  var halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition(_ref5) {\n  var height = _ref5.height,\n    affixHeight = _ref5.affixHeight,\n    labelYOffset = _ref5.labelYOffset;\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport var calculateFlatInputHorizontalPadding = function calculateFlatInputHorizontalPadding(_ref6) {\n  var adornmentConfig = _ref6.adornmentConfig,\n    isV3 = _ref6.isV3;\n  var _getConstants = getConstants(isV3),\n    LABEL_PADDING_HORIZONTAL = _getConstants.LABEL_PADDING_HORIZONTAL,\n    ADORNMENT_OFFSET = _getConstants.ADORNMENT_OFFSET,\n    FLAT_INPUT_OFFSET = _getConstants.FLAT_INPUT_OFFSET;\n  var paddingLeft = LABEL_PADDING_HORIZONTAL;\n  var paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(function (_ref7) {\n    var type = _ref7.type,\n      side = _ref7.side;\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft: paddingLeft,\n    paddingRight: paddingRight\n  };\n};\nvar getInputTextColor = function getInputTextColor(_ref8) {\n  var theme = _ref8.theme,\n    disabled = _ref8.disabled,\n    mode = _ref8.mode;\n  var isFlat = mode === 'flat';\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n    if (isFlat) {\n      return theme.colors.onSurfaceVariant;\n    }\n    return theme.colors.onSurface;\n  }\n  if (disabled) {\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n  return theme.colors.text;\n};\nvar getActiveColor = function getActiveColor(_ref9) {\n  var theme = _ref9.theme,\n    disabled = _ref9.disabled,\n    error = _ref9.error,\n    activeUnderlineColor = _ref9.activeUnderlineColor,\n    activeOutlineColor = _ref9.activeOutlineColor,\n    mode = _ref9.mode;\n  var isFlat = mode === 'flat';\n  var modeColor = isFlat ? activeUnderlineColor : activeOutlineColor;\n  if (error) {\n    return theme.colors.error;\n  }\n  if (modeColor) {\n    return modeColor;\n  }\n  if (disabled) {\n    if (theme.isV3) {\n      return theme.colors.onSurfaceDisabled;\n    }\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n  return theme.colors.primary;\n};\nvar getPlaceholderColor = function getPlaceholderColor(_ref10) {\n  var theme = _ref10.theme,\n    disabled = _ref10.disabled;\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n    return theme.colors.onSurfaceVariant;\n  }\n  if (disabled) {\n    return theme.colors.disabled;\n  }\n  return theme.colors.placeholder;\n};\nvar getFlatBackgroundColor = function getFlatBackgroundColor(_ref11) {\n  var _theme$colors, _theme$colors2;\n  var theme = _ref11.theme,\n    disabled = _ref11.disabled;\n  if (theme.isV3) {\n    if (disabled) {\n      return color(MD3LightTheme.colors.onSecondaryContainer).alpha(0.08).rgb().string();\n    } else {\n      return theme.colors.surfaceVariant;\n    }\n  }\n  if (disabled) {\n    return undefined;\n  }\n  return theme.dark ? color((_theme$colors = theme.colors) === null || _theme$colors === void 0 ? void 0 : _theme$colors.background).lighten(0.24).rgb().string() : color((_theme$colors2 = theme.colors) === null || _theme$colors2 === void 0 ? void 0 : _theme$colors2.background).darken(0.06).rgb().string();\n};\nvar getFlatUnderlineColor = function getFlatUnderlineColor(_ref12) {\n  var theme = _ref12.theme,\n    disabled = _ref12.disabled,\n    underlineColor = _ref12.underlineColor;\n  if (!disabled && underlineColor) {\n    return underlineColor;\n  }\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n    return theme.colors.onSurface;\n  }\n  if (disabled) {\n    return 'transparent';\n  }\n  return theme.colors.disabled;\n};\nvar getOutlinedOutlineInputColor = function getOutlinedOutlineInputColor(_ref13) {\n  var theme = _ref13.theme,\n    disabled = _ref13.disabled,\n    customOutlineColor = _ref13.customOutlineColor;\n  var isTransparent = color(customOutlineColor).alpha() === 0;\n  if (!disabled && customOutlineColor) {\n    return customOutlineColor;\n  }\n  if (theme.isV3) {\n    if (disabled) {\n      if (theme.dark) {\n        return 'transparent';\n      }\n      return theme.colors.surfaceDisabled;\n    }\n    return theme.colors.outline;\n  }\n  if (disabled) {\n    if (isTransparent) {\n      return customOutlineColor;\n    }\n    return theme.colors.disabled;\n  }\n  return theme.colors.placeholder;\n};\nexport var getFlatInputColors = function getFlatInputColors(_ref14) {\n  var underlineColor = _ref14.underlineColor,\n    activeUnderlineColor = _ref14.activeUnderlineColor,\n    disabled = _ref14.disabled,\n    error = _ref14.error,\n    theme = _ref14.theme;\n  var baseFlatColorProps = {\n    theme: theme,\n    disabled: disabled\n  };\n  return {\n    inputTextColor: getInputTextColor(_objectSpread(_objectSpread({}, baseFlatColorProps), {}, {\n      mode: 'flat'\n    })),\n    activeColor: getActiveColor(_objectSpread(_objectSpread({}, baseFlatColorProps), {}, {\n      error: error,\n      activeUnderlineColor: activeUnderlineColor,\n      mode: 'flat'\n    })),\n    underlineColorCustom: getFlatUnderlineColor(_objectSpread(_objectSpread({}, baseFlatColorProps), {}, {\n      underlineColor: underlineColor\n    })),\n    placeholderColor: getPlaceholderColor(baseFlatColorProps),\n    errorColor: theme.colors.error,\n    backgroundColor: getFlatBackgroundColor(baseFlatColorProps)\n  };\n};\nexport var getOutlinedInputColors = function getOutlinedInputColors(_ref15) {\n  var activeOutlineColor = _ref15.activeOutlineColor,\n    customOutlineColor = _ref15.customOutlineColor,\n    disabled = _ref15.disabled,\n    error = _ref15.error,\n    theme = _ref15.theme;\n  var baseOutlinedColorProps = {\n    theme: theme,\n    disabled: disabled\n  };\n  return {\n    inputTextColor: getInputTextColor(_objectSpread(_objectSpread({}, baseOutlinedColorProps), {}, {\n      mode: 'outlined'\n    })),\n    activeColor: getActiveColor(_objectSpread(_objectSpread({}, baseOutlinedColorProps), {}, {\n      error: error,\n      activeOutlineColor: activeOutlineColor,\n      mode: 'outlined'\n    })),\n    outlineColor: getOutlinedOutlineInputColor(_objectSpread(_objectSpread({}, baseOutlinedColorProps), {}, {\n      customOutlineColor: customOutlineColor\n    })),\n    placeholderColor: getPlaceholderColor(baseOutlinedColorProps),\n    errorColor: theme.colors.error\n  };\n};\nexport var getConstants = function getConstants(isV3) {\n  var AFFIX_OFFSET;\n\n  var ICON_OFFSET;\n\n  var LABEL_PADDING_TOP;\n  var LABEL_PADDING_HORIZONTAL;\n  var FLAT_INPUT_OFFSET;\n  var MIN_HEIGHT;\n\n  var INPUT_PADDING_HORIZONTAL;\n  var ADORNMENT_OFFSET;\n  var OUTLINED_INPUT_OFFSET;\n  if (isV3) {\n    AFFIX_OFFSET = MD3_AFFIX_OFFSET;\n    ICON_OFFSET = MD3_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD3_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD3_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD3_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD3_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD3_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD3_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD3_OUTLINED_INPUT_OFFSET;\n  } else {\n    AFFIX_OFFSET = MD2_AFFIX_OFFSET;\n    ICON_OFFSET = MD2_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD2_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD2_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD2_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD2_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD2_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD2_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD2_OUTLINED_INPUT_OFFSET;\n  }\n  return {\n    AFFIX_OFFSET: AFFIX_OFFSET,\n    ICON_OFFSET: ICON_OFFSET,\n    LABEL_PADDING_TOP: LABEL_PADDING_TOP,\n    LABEL_PADDING_HORIZONTAL: LABEL_PADDING_HORIZONTAL,\n    FLAT_INPUT_OFFSET: FLAT_INPUT_OFFSET,\n    MIN_HEIGHT: MIN_HEIGHT,\n    INPUT_PADDING_HORIZONTAL: INPUT_PADDING_HORIZONTAL,\n    ADORNMENT_OFFSET: ADORNMENT_OFFSET,\n    OUTLINED_INPUT_OFFSET: OUTLINED_INPUT_OFFSET\n  };\n};","map":{"version":3,"mappings":"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","names":["color","ADORNMENT_SIZE","MD3_LABEL_PADDING_HORIZONTAL","MD2_LABEL_PADDING_HORIZONTAL","MD3_ADORNMENT_OFFSET","MD2_ADORNMENT_OFFSET","MD3_FLAT_INPUT_OFFSET","MD2_FLAT_INPUT_OFFSET","MD3_AFFIX_OFFSET","MD2_AFFIX_OFFSET","MD3_ICON_OFFSET","MD2_ICON_OFFSET","MD3_LABEL_PADDING_TOP","MD2_LABEL_PADDING_TOP","MD3_MIN_HEIGHT","MD2_MIN_HEIGHT","MD3_INPUT_PADDING_HORIZONTAL","MD2_INPUT_PADDING_HORIZONTAL","MD3_OUTLINED_INPUT_OFFSET","MD2_OUTLINED_INPUT_OFFSET","AdornmentType","AdornmentSide","MD3LightTheme","calculateLabelTopPosition","labelHeight","height","optionalPadding","customHeight","Math","floor","calculateInputHeight","minHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","max","dense","_ref","topPosition","fontSize","scale","offset","isAndroid","refFontSize","min","adjustPaddingOut","_ref2","pad","label","lineHeight","fontHeight","refFontHeight","paddingTop","paddingBottom","adjustPaddingFlat","_ref3","styles","topResult","bottomResult","interpolatePlaceholder","labeled","hasActiveOutline","interpolate","inputRange","outputRange","calculateFlatAffixTopPosition","_ref4","affixHeight","inputHeightWithoutPadding","halfOfTheInputHeightDecreasedByAffixHeight","calculateOutlinedIconAndAffixTopPosition","_ref5","labelYOffset","calculateFlatInputHorizontalPadding","_ref6","adornmentConfig","isV3","getConstants","LABEL_PADDING_HORIZONTAL","ADORNMENT_OFFSET","FLAT_INPUT_OFFSET","paddingLeft","paddingRight","forEach","type","_ref7","side","Icon","Left","Right","Affix","getInputTextColor","_ref8","theme","disabled","mode","isFlat","colors","onSurfaceDisabled","onSurfaceVariant","onSurface","text","alpha","rgb","string","getActiveColor","_ref9","error","activeUnderlineColor","activeOutlineColor","modeColor","primary","getPlaceholderColor","_ref10","placeholder","getFlatBackgroundColor","_ref11","onSecondaryContainer","surfaceVariant","undefined","dark","_theme$colors","background","lighten","_theme$colors2","darken","getFlatUnderlineColor","_ref12","underlineColor","getOutlinedOutlineInputColor","_ref13","customOutlineColor","isTransparent","surfaceDisabled","outline","getFlatInputColors","_ref14","baseFlatColorProps","inputTextColor","activeColor","underlineColorCustom","placeholderColor","errorColor","backgroundColor","getOutlinedInputColors","_ref15","baseOutlinedColorProps","outlineColor","AFFIX_OFFSET","ICON_OFFSET","LABEL_PADDING_TOP","MIN_HEIGHT","INPUT_PADDING_HORIZONTAL","OUTLINED_INPUT_OFFSET"],"sources":["helpers.tsx"],"sourcesContent":["import type { Animated } from 'react-native';\nimport color from 'color';\nimport type { AdornmentConfig } from './Adornment/types';\nimport {\n  ADORNMENT_SIZE,\n  MD3_LABEL_PADDING_HORIZONTAL,\n  MD2_LABEL_PADDING_HORIZONTAL,\n  MD3_ADORNMENT_OFFSET,\n  MD2_ADORNMENT_OFFSET,\n  MD3_FLAT_INPUT_OFFSET,\n  MD2_FLAT_INPUT_OFFSET,\n  MD3_AFFIX_OFFSET,\n  MD2_AFFIX_OFFSET,\n  MD3_ICON_OFFSET,\n  MD2_ICON_OFFSET,\n  MD3_LABEL_PADDING_TOP,\n  MD2_LABEL_PADDING_TOP,\n  MD3_MIN_HEIGHT,\n  MD2_MIN_HEIGHT,\n  MD3_INPUT_PADDING_HORIZONTAL,\n  MD2_INPUT_PADDING_HORIZONTAL,\n  MD3_OUTLINED_INPUT_OFFSET,\n  MD2_OUTLINED_INPUT_OFFSET,\n} from './constants';\nimport { AdornmentType, AdornmentSide } from './Adornment/enums';\nimport type { TextInputLabelProp } from './types';\nimport { MD3LightTheme } from '../../styles/themes';\nimport type { Theme } from '../../types';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  lineHeight?: number;\n  label?: TextInputLabelProp | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const fontHeight = lineHeight ?? fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontHeight / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontHeight * scale)\n            : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport const interpolatePlaceholder = (\n  labeled: Animated.Value,\n  hasActiveOutline: boolean | undefined\n) =>\n  labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1],\n  });\n\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight,\n}: {\n  height: number;\n  paddingTop: number;\n  paddingBottom: number;\n  affixHeight: number;\n}): number {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n\n  const halfOfTheInputHeightDecreasedByAffixHeight =\n    (inputHeightWithoutPadding - affixHeight) / 2;\n\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\n\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset,\n}: {\n  height: number;\n  affixHeight: number;\n  labelYOffset: number;\n}): number {\n  return (height - affixHeight + labelYOffset) / 2;\n}\n\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n  isV3,\n}: {\n  adornmentConfig: AdornmentConfig[];\n  isV3?: boolean;\n}) => {\n  const { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, FLAT_INPUT_OFFSET } =\n    getConstants(isV3);\n\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n\n  adornmentConfig.forEach(({ type, side }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n\n  return { paddingLeft, paddingRight };\n};\n\ntype BaseProps = {\n  theme: Theme;\n  disabled?: boolean;\n};\n\ntype Mode = 'flat' | 'outlined';\n\nconst getInputTextColor = ({\n  theme,\n  disabled,\n  mode,\n}: BaseProps & { mode: Mode }) => {\n  const isFlat = mode === 'flat';\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    if (isFlat) {\n      return theme.colors.onSurfaceVariant;\n    }\n\n    return theme.colors.onSurface;\n  }\n\n  if (disabled) {\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n\n  return theme.colors.text;\n};\n\nconst getActiveColor = ({\n  theme,\n  disabled,\n  error,\n  activeUnderlineColor,\n  activeOutlineColor,\n  mode,\n}: BaseProps & {\n  error?: boolean;\n  activeUnderlineColor?: string;\n  activeOutlineColor?: string;\n  mode?: Mode;\n}) => {\n  const isFlat = mode === 'flat';\n  const modeColor = isFlat ? activeUnderlineColor : activeOutlineColor;\n\n  if (error) {\n    return theme.colors.error;\n  }\n\n  if (modeColor) {\n    return modeColor;\n  }\n\n  if (disabled) {\n    if (theme.isV3) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n\n  return theme.colors.primary;\n};\n\nconst getPlaceholderColor = ({ theme, disabled }: BaseProps) => {\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurfaceVariant;\n  }\n\n  if (disabled) {\n    return theme.colors.disabled;\n  }\n\n  return theme.colors.placeholder;\n};\n\nconst getFlatBackgroundColor = ({ theme, disabled }: BaseProps) => {\n  if (theme.isV3) {\n    if (disabled) {\n      // @ts-ignore According to Figma for both themes the base color for disabled in `onSecondaryContainer`\n      return color(MD3LightTheme.colors.onSecondaryContainer)\n        .alpha(0.08)\n        .rgb()\n        .string();\n    } else {\n      return theme.colors.surfaceVariant;\n    }\n  }\n\n  if (disabled) {\n    return undefined;\n  }\n\n  return theme.dark\n    ? color(theme.colors?.background).lighten(0.24).rgb().string()\n    : color(theme.colors?.background).darken(0.06).rgb().string();\n};\n\nconst getFlatUnderlineColor = ({\n  theme,\n  disabled,\n  underlineColor,\n}: BaseProps & { underlineColor?: string }) => {\n  if (!disabled && underlineColor) {\n    return underlineColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurface;\n  }\n\n  if (disabled) {\n    return 'transparent';\n  }\n\n  return theme.colors.disabled;\n};\n\nconst getOutlinedOutlineInputColor = ({\n  theme,\n  disabled,\n  customOutlineColor,\n}: BaseProps & { customOutlineColor?: string }) => {\n  const isTransparent = color(customOutlineColor).alpha() === 0;\n\n  if (!disabled && customOutlineColor) {\n    return customOutlineColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      if (theme.dark) {\n        return 'transparent';\n      }\n      return theme.colors.surfaceDisabled;\n    }\n\n    return theme.colors.outline;\n  }\n\n  if (disabled) {\n    if (isTransparent) {\n      return customOutlineColor;\n    }\n    return theme.colors.disabled;\n  }\n  return theme.colors.placeholder;\n};\n\nexport const getFlatInputColors = ({\n  underlineColor,\n  activeUnderlineColor,\n  disabled,\n  error,\n  theme,\n}: {\n  underlineColor?: string;\n  activeUnderlineColor?: string;\n  disabled?: boolean;\n  error?: boolean;\n  theme: Theme;\n}) => {\n  const baseFlatColorProps = { theme, disabled };\n  return {\n    inputTextColor: getInputTextColor({ ...baseFlatColorProps, mode: 'flat' }),\n    activeColor: getActiveColor({\n      ...baseFlatColorProps,\n      error,\n      activeUnderlineColor,\n      mode: 'flat',\n    }),\n    underlineColorCustom: getFlatUnderlineColor({\n      ...baseFlatColorProps,\n      underlineColor,\n    }),\n    placeholderColor: getPlaceholderColor(baseFlatColorProps),\n    errorColor: theme.colors.error,\n    backgroundColor: getFlatBackgroundColor(baseFlatColorProps),\n  };\n};\n\nexport const getOutlinedInputColors = ({\n  activeOutlineColor,\n  customOutlineColor,\n  disabled,\n  error,\n  theme,\n}: {\n  activeOutlineColor?: string;\n  customOutlineColor?: string;\n  disabled?: boolean;\n  error?: boolean;\n  theme: Theme;\n}) => {\n  const baseOutlinedColorProps = { theme, disabled };\n\n  return {\n    inputTextColor: getInputTextColor({\n      ...baseOutlinedColorProps,\n      mode: 'outlined',\n    }),\n    activeColor: getActiveColor({\n      ...baseOutlinedColorProps,\n      error,\n      activeOutlineColor,\n      mode: 'outlined',\n    }),\n    outlineColor: getOutlinedOutlineInputColor({\n      ...baseOutlinedColorProps,\n      customOutlineColor,\n    }),\n    placeholderColor: getPlaceholderColor(baseOutlinedColorProps),\n    errorColor: theme.colors.error,\n  };\n};\n\nexport const getConstants = (isV3?: boolean) => {\n  // Text input affix\n  let AFFIX_OFFSET;\n  // Text input icon\n  let ICON_OFFSET;\n  //Text input flat\n  let LABEL_PADDING_TOP;\n  let LABEL_PADDING_HORIZONTAL;\n  let FLAT_INPUT_OFFSET;\n  let MIN_HEIGHT;\n  // Text input outlined;\n  let INPUT_PADDING_HORIZONTAL;\n  let ADORNMENT_OFFSET;\n  let OUTLINED_INPUT_OFFSET;\n\n  if (isV3) {\n    AFFIX_OFFSET = MD3_AFFIX_OFFSET;\n    ICON_OFFSET = MD3_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD3_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD3_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD3_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD3_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD3_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD3_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD3_OUTLINED_INPUT_OFFSET;\n  } else {\n    AFFIX_OFFSET = MD2_AFFIX_OFFSET;\n    ICON_OFFSET = MD2_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD2_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD2_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD2_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD2_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD2_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD2_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD2_OUTLINED_INPUT_OFFSET;\n  }\n\n  return {\n    AFFIX_OFFSET,\n    ICON_OFFSET,\n    LABEL_PADDING_TOP,\n    LABEL_PADDING_HORIZONTAL,\n    FLAT_INPUT_OFFSET,\n    MIN_HEIGHT,\n    INPUT_PADDING_HORIZONTAL,\n    ADORNMENT_OFFSET,\n    OUTLINED_INPUT_OFFSET,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}